/* tslint:disable */
/* eslint-disable */
/**
 * Cats example
 * The cats API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthControllerMe200Response
 */
export interface AuthControllerMe200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthControllerMe200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {AuthControllerMe200ResponseAllOfMessage}
     * @memberof AuthControllerMe200Response
     */
    'message'?: AuthControllerMe200ResponseAllOfMessage;
}
/**
 * 
 * @export
 * @interface AuthControllerMe200ResponseAllOfMessage
 */
export interface AuthControllerMe200ResponseAllOfMessage {
    /**
     * 
     * @type {string}
     * @memberof AuthControllerMe200ResponseAllOfMessage
     */
    'tr'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerMe200ResponseAllOfMessage
     */
    'en'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerMe400Response
 */
export interface AuthControllerMe400Response {
    /**
     * 
     * @type {AuthControllerMe400ResponseAllOfMessage}
     * @memberof AuthControllerMe400Response
     */
    'message'?: AuthControllerMe400ResponseAllOfMessage;
}
/**
 * 
 * @export
 * @interface AuthControllerMe400ResponseAllOfMessage
 */
export interface AuthControllerMe400ResponseAllOfMessage {
    /**
     * 
     * @type {string}
     * @memberof AuthControllerMe400ResponseAllOfMessage
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerMe400ResponseAllOfMessage
     */
    'tr'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerMe400ResponseAllOfMessage
     */
    'en'?: string;
}
/**
 * 
 * @export
 * @interface AuthResponseSuccess
 */
export interface AuthResponseSuccess {
    /**
     * 
     * @type {boolean}
     * @memberof AuthResponseSuccess
     */
    'success': boolean;
    /**
     * 
     * @type {AuthResponseSuccessMessage}
     * @memberof AuthResponseSuccess
     */
    'message': AuthResponseSuccessMessage;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSuccess
     */
    'token': string;
    /**
     * 
     * @type {AuthResponseSuccessUser}
     * @memberof AuthResponseSuccess
     */
    'user': AuthResponseSuccessUser;
}
/**
 * 
 * @export
 * @interface AuthResponseSuccessMessage
 */
export interface AuthResponseSuccessMessage {
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSuccessMessage
     */
    'tr'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSuccessMessage
     */
    'en'?: string;
}
/**
 * 
 * @export
 * @interface AuthResponseSuccessUser
 */
export interface AuthResponseSuccessUser {
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSuccessUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSuccessUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseSuccessUser
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthResponseSuccessUser
     */
    'emailVerified'?: boolean;
}
/**
 * 
 * @export
 * @interface BadRequestResponse
 */
export interface BadRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof BadRequestResponse
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof BadRequestResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {boolean}
     * @memberof BadRequestResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {RegisterResponse400Message}
     * @memberof BadRequestResponse
     */
    'message': RegisterResponse400Message;
}
/**
 * 
 * @export
 * @interface BrandsControllerCreatePermission201Response
 */
export interface BrandsControllerCreatePermission201Response {
    /**
     * 
     * @type {string}
     * @memberof BrandsControllerCreatePermission201Response
     */
    'status': BrandsControllerCreatePermission201ResponseStatusEnum;
    /**
     * 
     * @type {BrandsResponse}
     * @memberof BrandsControllerCreatePermission201Response
     */
    'record'?: BrandsResponse;
}

export const BrandsControllerCreatePermission201ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type BrandsControllerCreatePermission201ResponseStatusEnum = typeof BrandsControllerCreatePermission201ResponseStatusEnum[keyof typeof BrandsControllerCreatePermission201ResponseStatusEnum];

/**
 * 
 * @export
 * @interface BrandsControllerListPermissions200Response
 */
export interface BrandsControllerListPermissions200Response {
    /**
     * Dinamik filtre nesnesi
     * @type {{ [key: string]: any; }}
     * @memberof BrandsControllerListPermissions200Response
     */
    'filter': { [key: string]: any; };
    /**
     * 
     * @type {PaginationDto}
     * @memberof BrandsControllerListPermissions200Response
     */
    'pagination': PaginationDto;
    /**
     * Sıralama seçenekleri dizisi
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BrandsControllerListPermissions200Response
     */
    'sortOptions': Array<{ [key: InnerEnum]: InnerEnum; }>;
    /**
     * 
     * @type {Array<BrandsResponse>}
     * @memberof BrandsControllerListPermissions200Response
     */
    'records'?: Array<BrandsResponse>;
}

export const BrandsControllerListPermissions200ResponseSortOptionsEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;

export type BrandsControllerListPermissions200ResponseSortOptionsEnum = typeof BrandsControllerListPermissions200ResponseSortOptionsEnum[keyof typeof BrandsControllerListPermissions200ResponseSortOptionsEnum];

/**
 * 
 * @export
 * @interface BrandsResponse
 */
export interface BrandsResponse {
    /**
     * 
     * @type {Array<MarketplacesResponseDataInner>}
     * @memberof BrandsResponse
     */
    'data': Array<MarketplacesResponseDataInner>;
    /**
     * 
     * @type {number}
     * @memberof BrandsResponse
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof BrandsResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof BrandsResponse
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'resetToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface CreateBrandDto
 */
export interface CreateBrandDto {
    /**
     * 
     * @type {string}
     * @memberof CreateBrandDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBrandDto
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationDto
 */
export interface CreateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface CreateResponseDto
 */
export interface CreateResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResponseDto
     */
    'status': CreateResponseDtoStatusEnum;
}

export const CreateResponseDtoStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type CreateResponseDtoStatusEnum = typeof CreateResponseDtoStatusEnum[keyof typeof CreateResponseDtoStatusEnum];

/**
 * 
 * @export
 * @interface ForbiddenResponse
 */
export interface ForbiddenResponse {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenResponse
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof ForbiddenResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {AuthResponseSuccessMessage}
     * @memberof ForbiddenResponse
     */
    'message': AuthResponseSuccessMessage;
}
/**
 * 
 * @export
 * @interface ListResponseDto
 */
export interface ListResponseDto {
    /**
     * Dinamik filtre nesnesi
     * @type {{ [key: string]: any; }}
     * @memberof ListResponseDto
     */
    'filter': { [key: string]: any; };
    /**
     * 
     * @type {PaginationDto}
     * @memberof ListResponseDto
     */
    'pagination': PaginationDto;
    /**
     * Sıralama seçenekleri dizisi
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ListResponseDto
     */
    'sortOptions': Array<{ [key: InnerEnum]: InnerEnum; }>;
}

export const ListResponseDtoSortOptionsEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;

export type ListResponseDtoSortOptionsEnum = typeof ListResponseDtoSortOptionsEnum[keyof typeof ListResponseDtoSortOptionsEnum];

/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse400
 */
export interface LoginResponse400 {
    /**
     * 
     * @type {LoginResponse400Message}
     * @memberof LoginResponse400
     */
    'message': LoginResponse400Message;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse400
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse400
     */
    'statusCode': number;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse400
     */
    'success'?: boolean;
}
/**
 * @type LoginResponse400Message
 * @export
 */
export type LoginResponse400Message = Array<string> | AuthResponseSuccessMessage;

/**
 * 
 * @export
 * @interface MarketplacesResponse
 */
export interface MarketplacesResponse {
    /**
     * 
     * @type {Array<MarketplacesResponseDataInner>}
     * @memberof MarketplacesResponse
     */
    'data': Array<MarketplacesResponseDataInner>;
    /**
     * 
     * @type {number}
     * @memberof MarketplacesResponse
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof MarketplacesResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof MarketplacesResponse
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface MarketplacesResponseDataInner
 */
export interface MarketplacesResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof MarketplacesResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MarketplacesResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MarketplacesResponseDataInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof MarketplacesResponseDataInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof MarketplacesResponseDataInner
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface OrganizationControllerCreateOrganization201Response
 */
export interface OrganizationControllerCreateOrganization201Response {
    /**
     * 
     * @type {string}
     * @memberof OrganizationControllerCreateOrganization201Response
     */
    'status': OrganizationControllerCreateOrganization201ResponseStatusEnum;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationControllerCreateOrganization201Response
     */
    'record'?: Organization;
}

export const OrganizationControllerCreateOrganization201ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type OrganizationControllerCreateOrganization201ResponseStatusEnum = typeof OrganizationControllerCreateOrganization201ResponseStatusEnum[keyof typeof OrganizationControllerCreateOrganization201ResponseStatusEnum];

/**
 * 
 * @export
 * @interface OrganizationControllerListOrganizations200Response
 */
export interface OrganizationControllerListOrganizations200Response {
    /**
     * Dinamik filtre nesnesi
     * @type {{ [key: string]: any; }}
     * @memberof OrganizationControllerListOrganizations200Response
     */
    'filter': { [key: string]: any; };
    /**
     * 
     * @type {PaginationDto}
     * @memberof OrganizationControllerListOrganizations200Response
     */
    'pagination': PaginationDto;
    /**
     * Sıralama seçenekleri dizisi
     * @type {Array<{ [key: string]: string; }>}
     * @memberof OrganizationControllerListOrganizations200Response
     */
    'sortOptions': Array<{ [key: InnerEnum]: InnerEnum; }>;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof OrganizationControllerListOrganizations200Response
     */
    'records'?: Array<Organization>;
}

export const OrganizationControllerListOrganizations200ResponseSortOptionsEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;

export type OrganizationControllerListOrganizations200ResponseSortOptionsEnum = typeof OrganizationControllerListOrganizations200ResponseSortOptionsEnum[keyof typeof OrganizationControllerListOrganizations200ResponseSortOptionsEnum];

/**
 * 
 * @export
 * @interface PaginationDto
 */
export interface PaginationDto {
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof Permission
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof Permission
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface PermissionControllerListPermissions200Response
 */
export interface PermissionControllerListPermissions200Response {
    /**
     * Dinamik filtre nesnesi
     * @type {{ [key: string]: any; }}
     * @memberof PermissionControllerListPermissions200Response
     */
    'filter': { [key: string]: any; };
    /**
     * 
     * @type {PaginationDto}
     * @memberof PermissionControllerListPermissions200Response
     */
    'pagination': PaginationDto;
    /**
     * Sıralama seçenekleri dizisi
     * @type {Array<{ [key: string]: string; }>}
     * @memberof PermissionControllerListPermissions200Response
     */
    'sortOptions': Array<{ [key: InnerEnum]: InnerEnum; }>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PermissionControllerListPermissions200Response
     */
    'records'?: Array<Permission>;
}

export const PermissionControllerListPermissions200ResponseSortOptionsEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;

export type PermissionControllerListPermissions200ResponseSortOptionsEnum = typeof PermissionControllerListPermissions200ResponseSortOptionsEnum[keyof typeof PermissionControllerListPermissions200ResponseSortOptionsEnum];

/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RegisterResponse400
 */
export interface RegisterResponse400 {
    /**
     * 
     * @type {RegisterResponse400Message}
     * @memberof RegisterResponse400
     */
    'message': RegisterResponse400Message;
    /**
     * 
     * @type {string}
     * @memberof RegisterResponse400
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterResponse400
     */
    'statusCode': number;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterResponse400
     */
    'success'?: boolean;
}
/**
 * @type RegisterResponse400Message
 * @export
 */
export type RegisterResponse400Message = Array<string> | RegisterResponse400MessageOneOf;

/**
 * 
 * @export
 * @interface RegisterResponse400MessageOneOf
 */
export interface RegisterResponse400MessageOneOf {
    /**
     * 
     * @type {string}
     * @memberof RegisterResponse400MessageOneOf
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterResponse400MessageOneOf
     */
    'tr'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterResponse400MessageOneOf
     */
    'en'?: string;
}
/**
 * 
 * @export
 * @interface ResetPasswordDto
 */
export interface ResetPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success': boolean;
    /**
     * 
     * @type {AuthResponseSuccessMessage}
     * @memberof SuccessResponse
     */
    'message': AuthResponseSuccessMessage;
}
/**
 * 
 * @export
 * @interface UnAuthorizedResponse
 */
export interface UnAuthorizedResponse {
    /**
     * 
     * @type {string}
     * @memberof UnAuthorizedResponse
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof UnAuthorizedResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {AuthResponseSuccessMessage}
     * @memberof UnAuthorizedResponse
     */
    'message': AuthResponseSuccessMessage;
}
/**
 * 
 * @export
 * @interface VerifyEmailDto
 */
export interface VerifyEmailDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'validationCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'token'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary change password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (changePasswordDto: ChangePasswordDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary user login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get user info
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerMe', 'token', token)
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary user register
         * @param {RegisterDto} registerDto 
         * @param {string} [inv] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, inv?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inv !== undefined) {
                localVarQueryParameter['inv'] = inv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resend verification mail
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResendVerification: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('authControllerResendVerification', 'authorization', authorization)
            const localVarPath = `/auth/resend-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary send reset password mail
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordDto: ResetPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordDto' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordDto', resetPasswordDto)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: All parameters in this endpoint can be filled optionally, but if there is an authorization header, it should be sent with the body validationCode, otherwise with the token.
         * @summary verify email
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (verifyEmailDto: VerifyEmailDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailDto' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'verifyEmailDto', verifyEmailDto)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary change password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(changePasswordDto: ChangePasswordDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(changePasswordDto, authorization, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerChangePassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary user login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponseSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerLogin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary get user info
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerMe(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerMe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerMe(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerMe']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerRefresh']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary user register
         * @param {RegisterDto} registerDto 
         * @param {string} [inv] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, inv?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponseSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, inv, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerRegister']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary resend verification mail
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResendVerification(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResendVerification(authorization, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerResendVerification']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary send reset password mail
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerResetPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Note: All parameters in this endpoint can be filled optionally, but if there is an authorization header, it should be sent with the body validationCode, otherwise with the token.
         * @summary verify email
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(verifyEmailDto, authorization, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerVerifyEmail']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary change password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(changePasswordDto: ChangePasswordDto, authorization?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerChangePassword(changePasswordDto, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary user login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: any): AxiosPromise<AuthResponseSuccess> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get user info
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe(token: string, options?: any): AxiosPromise<AuthControllerMe200Response> {
            return localVarFp.authControllerMe(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(options?: any): AxiosPromise<object> {
            return localVarFp.authControllerRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary user register
         * @param {RegisterDto} registerDto 
         * @param {string} [inv] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, inv?: string, options?: any): AxiosPromise<AuthResponseSuccess> {
            return localVarFp.authControllerRegister(registerDto, inv, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary resend verification mail
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResendVerification(authorization: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerResendVerification(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary send reset password mail
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerResetPassword(resetPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: All parameters in this endpoint can be filled optionally, but if there is an authorization header, it should be sent with the body validationCode, otherwise with the token.
         * @summary verify email
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, authorization?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.authControllerVerifyEmail(verifyEmailDto, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary change password
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerChangePassword(changePasswordDto: ChangePasswordDto, authorization?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerChangePassword(changePasswordDto, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary user login
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get user info
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerMe(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerMe(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefresh(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary user register
     * @param {RegisterDto} registerDto 
     * @param {string} [inv] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRegister(registerDto: RegisterDto, inv?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRegister(registerDto, inv, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary resend verification mail
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResendVerification(authorization: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResendVerification(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary send reset password mail
     * @param {ResetPasswordDto} resetPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(resetPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: All parameters in this endpoint can be filled optionally, but if there is an authorization header, it should be sent with the body validationCode, otherwise with the token.
     * @summary verify email
     * @param {VerifyEmailDto} verifyEmailDto 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, authorization?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(verifyEmailDto, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrandsApi - axios parameter creator
 * @export
 */
export const BrandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create BrandsResponse
         * @param {string} authorization JWT Token
         * @param {CreateBrandDto} createBrandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsControllerCreatePermission: async (authorization: string, createBrandDto: CreateBrandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('brandsControllerCreatePermission', 'authorization', authorization)
            // verify required parameter 'createBrandDto' is not null or undefined
            assertParamExists('brandsControllerCreatePermission', 'createBrandDto', createBrandDto)
            const localVarPath = `/brands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBrandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list BrandsResponses
         * @param {string} authorization JWT Token
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsControllerListPermissions: async (authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('brandsControllerListPermissions', 'authorization', authorization)
            const localVarPath = `/brands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandsApi - functional programming interface
 * @export
 */
export const BrandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary create BrandsResponse
         * @param {string} authorization JWT Token
         * @param {CreateBrandDto} createBrandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsControllerCreatePermission(authorization: string, createBrandDto: CreateBrandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsControllerCreatePermission(authorization, createBrandDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandsApi.brandsControllerCreatePermission']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary list BrandsResponses
         * @param {string} authorization JWT Token
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsControllerListPermissions(authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandsControllerListPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsControllerListPermissions(authorization, limit, page, orderBy, desc, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandsApi.brandsControllerListPermissions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BrandsApi - factory interface
 * @export
 */
export const BrandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandsApiFp(configuration)
    return {
        /**
         * 
         * @summary create BrandsResponse
         * @param {string} authorization JWT Token
         * @param {CreateBrandDto} createBrandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsControllerCreatePermission(authorization: string, createBrandDto: CreateBrandDto, options?: any): AxiosPromise<object> {
            return localVarFp.brandsControllerCreatePermission(authorization, createBrandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list BrandsResponses
         * @param {string} authorization JWT Token
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsControllerListPermissions(authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: any): AxiosPromise<BrandsControllerListPermissions200Response> {
            return localVarFp.brandsControllerListPermissions(authorization, limit, page, orderBy, desc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandsApi - object-oriented interface
 * @export
 * @class BrandsApi
 * @extends {BaseAPI}
 */
export class BrandsApi extends BaseAPI {
    /**
     * 
     * @summary create BrandsResponse
     * @param {string} authorization JWT Token
     * @param {CreateBrandDto} createBrandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandsApi
     */
    public brandsControllerCreatePermission(authorization: string, createBrandDto: CreateBrandDto, options?: RawAxiosRequestConfig) {
        return BrandsApiFp(this.configuration).brandsControllerCreatePermission(authorization, createBrandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list BrandsResponses
     * @param {string} authorization JWT Token
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [orderBy] 
     * @param {boolean} [desc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandsApi
     */
    public brandsControllerListPermissions(authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: RawAxiosRequestConfig) {
        return BrandsApiFp(this.configuration).brandsControllerListPermissions(authorization, limit, page, orderBy, desc, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckControllerGetHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckControllerGetHealthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckControllerGetHealthCheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.healthCheckControllerGetHealthCheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckControllerGetHealthCheck(options?: any): AxiosPromise<string> {
            return localVarFp.healthCheckControllerGetHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckControllerGetHealthCheck(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckControllerGetHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarketplaceApi - axios parameter creator
 * @export
 */
export const MarketplaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary list marketplaces
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerListPermissions: async (limit?: number, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/marketplaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplace 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerSearchCategory: async (marketplace: string, search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplace' is not null or undefined
            assertParamExists('marketplaceControllerSearchCategory', 'marketplace', marketplace)
            // verify required parameter 'search' is not null or undefined
            assertParamExists('marketplaceControllerSearchCategory', 'search', search)
            const localVarPath = `/marketplaces/{marketplace}/categories`
                .replace(`{${"marketplace"}}`, encodeURIComponent(String(marketplace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketplaceApi - functional programming interface
 * @export
 */
export const MarketplaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketplaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary list marketplaces
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerListPermissions(limit?: number, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerListPermissions(limit, page, search, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MarketplaceApi.marketplaceControllerListPermissions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} marketplace 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerSearchCategory(marketplace: string, search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerSearchCategory(marketplace, search, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MarketplaceApi.marketplaceControllerSearchCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MarketplaceApi - factory interface
 * @export
 */
export const MarketplaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketplaceApiFp(configuration)
    return {
        /**
         * 
         * @summary list marketplaces
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerListPermissions(limit?: number, page?: number, search?: string, options?: any): AxiosPromise<MarketplacesResponse> {
            return localVarFp.marketplaceControllerListPermissions(limit, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplace 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerSearchCategory(marketplace: string, search: string, options?: any): AxiosPromise<object> {
            return localVarFp.marketplaceControllerSearchCategory(marketplace, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketplaceApi - object-oriented interface
 * @export
 * @class MarketplaceApi
 * @extends {BaseAPI}
 */
export class MarketplaceApi extends BaseAPI {
    /**
     * 
     * @summary list marketplaces
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerListPermissions(limit?: number, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerListPermissions(limit, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplace 
     * @param {string} search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerSearchCategory(marketplace: string, search: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerSearchCategory(marketplace, search, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create Organization
         * @param {string} authorization JWT Token
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerCreateOrganization: async (authorization: string, createOrganizationDto: CreateOrganizationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('organizationControllerCreateOrganization', 'authorization', authorization)
            // verify required parameter 'createOrganizationDto' is not null or undefined
            assertParamExists('organizationControllerCreateOrganization', 'createOrganizationDto', createOrganizationDto)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list Organizations
         * @param {string} authorization JWT Token
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerListOrganizations: async (authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('organizationControllerListOrganizations', 'authorization', authorization)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary create Organization
         * @param {string} authorization JWT Token
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerCreateOrganization(authorization: string, createOrganizationDto: CreateOrganizationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationControllerCreateOrganization201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerCreateOrganization(authorization, createOrganizationDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrganizationsApi.organizationControllerCreateOrganization']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary list Organizations
         * @param {string} authorization JWT Token
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerListOrganizations(authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationControllerListOrganizations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerListOrganizations(authorization, limit, page, orderBy, desc, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrganizationsApi.organizationControllerListOrganizations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary create Organization
         * @param {string} authorization JWT Token
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerCreateOrganization(authorization: string, createOrganizationDto: CreateOrganizationDto, options?: any): AxiosPromise<OrganizationControllerCreateOrganization201Response> {
            return localVarFp.organizationControllerCreateOrganization(authorization, createOrganizationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list Organizations
         * @param {string} authorization JWT Token
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerListOrganizations(authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: any): AxiosPromise<OrganizationControllerListOrganizations200Response> {
            return localVarFp.organizationControllerListOrganizations(authorization, limit, page, orderBy, desc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary create Organization
     * @param {string} authorization JWT Token
     * @param {CreateOrganizationDto} createOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerCreateOrganization(authorization: string, createOrganizationDto: CreateOrganizationDto, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerCreateOrganization(authorization, createOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list Organizations
     * @param {string} authorization JWT Token
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [orderBy] 
     * @param {boolean} [desc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerListOrganizations(authorization: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerListOrganizations(authorization, limit, page, orderBy, desc, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary list Permissions
         * @param {string} authorization JWT Token
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerListPermissions: async (authorization: string, search?: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('permissionControllerListPermissions', 'authorization', authorization)
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary list Permissions
         * @param {string} authorization JWT Token
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerListPermissions(authorization: string, search?: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionControllerListPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerListPermissions(authorization, search, limit, page, orderBy, desc, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PermissionsApi.permissionControllerListPermissions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * 
         * @summary list Permissions
         * @param {string} authorization JWT Token
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [orderBy] 
         * @param {boolean} [desc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerListPermissions(authorization: string, search?: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: any): AxiosPromise<PermissionControllerListPermissions200Response> {
            return localVarFp.permissionControllerListPermissions(authorization, search, limit, page, orderBy, desc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @summary list Permissions
     * @param {string} authorization JWT Token
     * @param {string} [search] 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [orderBy] 
     * @param {boolean} [desc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerListPermissions(authorization: string, search?: string, limit?: number, page?: number, orderBy?: string, desc?: boolean, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerListPermissions(authorization, search, limit, page, orderBy, desc, options).then((request) => request(this.axios, this.basePath));
    }
}



